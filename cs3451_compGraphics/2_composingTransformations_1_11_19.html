<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Computer Graphics</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs3451Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Computer Graphics</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDay_1_7_19.html">0. First Day</a></li><li><a class="is-note-link" href="1_2dTransformations_1_9_19.html">1. Basic 2D Transformations</a></li><li class="active-note-page"><a class="is-note-link" href="2_composingTransformations_1_11_19.html">2. Composing 2D Transformations</a></li><li><a class="is-note-link" href="3_matrixStack_1_14_19.html">3. Matrix Stack Basics</a></li><li><a class="is-note-link" href="4_matrixStackCont_1_16_19.html">4. Matrix Stack (cont.)</a></li><li><a class="is-note-link" href="5_projectionBasics_1_18_19.html">5. Projection Basics</a></li><li><a class="is-note-link" href="6_arbitraryRotations_1_23_19.html">6. Arbitrary Rotations</a></li><li><a class="is-note-link" href="7_viewingTransform_1_25_19.html">7. Viewing Transformation</a></li><li><a class="is-note-link" href="8_displaysLines_1_28_19.html">8. Displays and Lines</a></li><li><a class="is-note-link" href="9_introRasterization_1_30_19.html">9. Intro to Rasterization</a></li><li><a class="is-note-link" href="10_hiddenSurfaces_2_1_19.html">10. Hidden Surfaces</a></li><li><a class="is-note-link" href="11_basicShading_2_4_19.html">11. Shading Basics</a></li><li><a class="is-note-link" href="12_basicShadingCont_2_6_19.html">12. Basic Shading (cont.)</a></li><li><a class="is-note-link" href="13_colorPerception_2_8_19.html">13. Color Perception</a></li><li><a class="is-note-link" href="14_colorSpaces_2_11_19.html">14. Color Spaces</a></li><li><a class="is-note-link" href="15_colorRaytracing_2_13_19.html">15. Color Space(cont.) / Intro to Raytracing</a></li><li><a class="is-note-link" href="16_raytracingIntersections_2_15_19.html">16. Raytracing Intersections</a></li><li><a class="is-note-link" href="17_moreRaytracing_2_18_19.html">17. Raytracing (cont.)</a></li><li><a class="is-note-link" href="18_evenMoreRaytracingShadows_2_20_19.html">18. Ray Tracing Shadows &amp; Effects</a></li><li><a class="is-note-link" href="19_raytracingOptimzation_2_22_19.html">19. Raytracing Optimization</a></li><li><a class="is-note-link" href="20_rasterEffects_2_27_19.html">20. Rasterization Effects</a></li><li><a class="is-note-link" href="21_textureMapping_3_1_19.html">21. Texture Mapping</a></li><li><a class="is-note-link" href="22_environmentMaps_3_4_19.html">22. Reflections and Environment Maps</a></li><li><a class="is-note-link" href="23_bumpMapsGPU_3_6_19.html">23. Bump Maps and GPUs</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="1_2dTransformations_1_9_19.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre class="main-note-text">//****************************************************************************//
//************ Composing 2D Transformations- January 11th, 2019 *************//
//**************************************************************************//

- The 4th row...it is a thing
---------------------------------------

- Okay, so on Wednesday we talked about the 3 major types of transformations: 
translation, scaling, and rotation
    - Translation, sadly, worked out to adding 2 vectors instead of 
    multitplying matrices...but then we found out that we COULD express it as a 
    matrix multiplication using "homogenous coordinates!"
        - "This is how graphic libraries handle transformations internally, as 
        matrix multiplications"

- Now, let's suppose we have the following problem: we have a little picture of 
a house (represented by Mr. Pentagon), and we want to rotate our home by 90 
degrees
    - If we just apply our rotation operation, we'd rotate about the origin
- But what if we want to rotate IN PLACE, so that we're rotating around the 
center of our object?
    - As it turns out, OpenGL has NO idea what we mean by the "center" of our 
    object - so how do we do this?
    - Well, if WE know where our house's center is, we can do it by moving our 
    house to the origin, rotating it, and then moving it back
        - i.e., we're TRANSLATING it!
- So, the process would look like:
    1) Translating our house so the center is at the origin (T1)
    2) Rotating our house however we want (R)
    3) Translating the house back to its original position (T2)
        - So, in matrix form, rotating our house around a point (a,b) by 90 
        degrees would look like:

            translate(-a,-b) -&gt; rotate(pi/2) -&gt; translate(a,b)

            T1 = [1 0 -a]   , R = [0 -1 0]  , T2 = [1 0 a]
                 [0 1 -b]         [1  0 0]         [0 1 b]
                 [0 0  1]         [0  0 1]         [0 0 1]

- However, REMEMBER that matrix multiplications happen right-to-left - so, we 
have to put the first operations at the END of the matrix multiplication
    - "Think of these as functions, and the idea of function composition - the 
    innermost function will get called first!"
    - Therefore, to rotate our point P to its new home:

        P' = T2( R( T1(P) ) ) = (T2*R*T1)*P

        - "DON'T FORGET THIS; you should always read the matrix operations 
        right-to-left, from the vector backwards"

- Notice here, though, that our matrix multiplications are associative - and, 
therefore, we can combine ALL of our operations into a single matrix just by 
multiplying them together!
    - "So, if we have a polygon with 5 million points or something, we don't 
    have to do 3 separate intense calculations to rotate it - we can just do 3 
    quick matrix operations to combine our tranformations, then do it once!"
- So, the key points to remember:
    1) Operation order matters
        - if we rotated before translating, we'd end up with a completely 
        different result!
    2) We can combine/compose multiple operations into one

- So, going back to our triangle from yesteryear, how would we translate it 2 
units to the left, and then double it in size? Well, it's a translation and a 
scaling - SO, writing out the handy-dandy matrices for these:

        T = [1 0 -2]      S = [2 0 0]
            [0 1  0]          [0 2 0]
            [0 0  1]          [0 0 1]

    - Combining them (don't forget to reverse the order, so translate happens 
    first!),

        ST = [2 0 0] * [1 0 -2] = [2 0 -4]
             [0 2 0]   [0 1  0]   [0 2  0]
             [0 0 1]   [0 0  1]   [0 0  1]

    - Great! Now, let's apply our combined translation-scaling operation to 
    each point in the tri-angled figure:

        [2 0 -4] * |  1| = | -2|
        [0 2  0]   |  1|   |  2|
        [0 0  1]   |{1}|   |{1}|

        (...do for the other 2 points...)

        - *had to add the 3rd coordinate to the vector to work w/ homogenous 
        coordinates

- Doing this in the OpenGL API would look something like this:

        glScale(2.0, 2.0);
        glTranslate(-2.0, 0.0);
        draw_triangle()

    - "This looks backwards, because we have to call our functions in the SAME 
    order as the matrix multiplications!" (i.e., the last-called operation is 
    done first!)
        - Why doesn't the library just handle this re-ordering for us? We'll 
        see an example on Monday where having control over this is useful

- Okay, we've established that in general, operations aren't commutative - but 
are ANY operations commutative with each other?
    - Well, translations DO commute with other translations (it's the same 
    thing as commuting additions)
        - ...but translations don't commute with rotations, uniform scaling, or 
        non-uniform scaling
            - all of these apply vice-versa as well (e.g. since translations 
            don't commute with rotations, rotations obviously also don't 
            commute with translations!)
    - Rotations commute with one another in 2D, and with uniform scaling!
        - ...but not with non-uniform scaling, and 3D rotations DON'T commute 
        with one another!
            - Why doesn't it work in 3D? Imagine rotating 90 degrees around X, 
            then Y, and vice versa - it just doesn't get you the same answer
    - Uniform scaling is really just multiplication, so it's commutative with 
    itself AND non-uniform scaling
        - ...but not with the other stuff

- On Monday, we'll start exploring the "matrix stack" and getting a little bit 
into OpenGL - until then, have a great weekend!

</pre>
</article>
<a class="side-link is-note-link" href="3_matrixStack_1_14_19.html"></a>
</main>
</body>
</html>