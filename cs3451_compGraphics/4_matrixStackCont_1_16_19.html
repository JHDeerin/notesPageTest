<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>(*TEST PAGE*) Jake's CS Notes - Computer Graphics</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs3451Theme.css" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#">Computer Graphics</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDay_1_7_19.html">0. First Day</a></li><li><a class="is-note-link" href="1_2dTransformations_1_9_19.html">1. Basic 2D Transformations</a></li><li><a class="is-note-link" href="2_composingTransformations_1_11_19.html">2. Composing 2D Transformations</a></li><li><a class="is-note-link" href="3_matrixStack_1_14_19.html">3. Matrix Stack Basics</a></li><li class="active-note-page"><a class="is-note-link" href="4_matrixStackCont_1_16_19.html">4. Matrix Stack (cont.)</a></li><li><a class="is-note-link" href="5_projectionBasics_1_18_19.html">5. Projection Basics</a></li><li><a class="is-note-link" href="6_arbitraryRotations_1_23_19.html">6. Arbitrary Rotations</a></li><li><a class="is-note-link" href="7_viewingTransform_1_25_19.html">7. Viewing Transformation</a></li><li><a class="is-note-link" href="8_displaysLines_1_28_19.html">8. Displays and Lines</a></li><li><a class="is-note-link" href="9_introRasterization_1_30_19.html">9. Intro to Rasterization</a></li><li><a class="is-note-link" href="10_hiddenSurfaces_2_1_19.html">10. Hidden Surfaces</a></li><li><a class="is-note-link" href="11_basicShading_2_4_19.html">11. Shading Basics</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="3_matrixStack_1_14_19.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre class="main-note-text">//****************************************************************************//
//************** Matrix Stack (cont.) - January 16th, 2019 ******************//
//**************************************************************************//

- Project 1, where art thou? Whence hast thy form fled from the sullen coves of 
earth?
------------------------------------------------

- Alright - last class, in our Frankensteinien hubris, we were creating a 
person - a tiny homunculus within our digital light-flashy boxes
    - As discussed, we can use the matrix stack to persistently transform thhe 
    stuff we're drawing - but we only got around to creating a lonely hand
    - Today, let's continue right along with our arm-drawing method

            void drawArm() {
                push()
                translate(6, 0); //position the hand at the end of the arm
                hand()
                pop(); //"Fuh-git-abowt-it"
                armExtent(); //draw the actual arm
            }
            void armExtent() {
                push()
                scale(3, 5);
                square();
                pop();
            }

    - Now for the torso, and the rest of our headless horseless man!

            void person() {
                push(); //copy a 2nd "I" onto the top of the stack
                scale(4, 5);
                square(); //draws the torso
                pop();

                push();
                translate(4, 4.5); //move the arm from the origin to the 
                top-right of the torso
                arm();
                pop();

                push();
                scale(-1, 1); //flip the x-direction, to draw the arm the other 
                way
                translate(-4, 4.5);
                arm();
                pop();
            }

    - Notice that, as we were writing this, we didn't have to think too hard 
    about what was inside the arm() method - we could just let the matrix stack 
    and our previous transformations handle that for us!
        - Each "matrix push" is like going level down the dependency tree for 
        these objects, and each pop is like going a level back
        - As we go downwards, we keep "accumulating" more transformations on 
        our matrix stack, adding each transformation to the right of our 
        equation (i.e. most recently added is the first one to be performed)
            - Then, when we draw an object, ALL the transformations on the top 
            of the matrix stack are applied to it!
    - This is the reason why the matrix stack behaves the way it does: it 
    handles this hierarchy of commands for us as a linear set of stuff, which 
    is great!
        - It seems unnecessarily complicated at first, but in the long run, 
        this matrix stack saves us a ton of work

- "If you can understand this example code I gave you, draw the matrix stack 
for it, and understand why it works the way it does, you should be in excellent 
shape with this"
    - ...and again, Professor Turk loves giving matrix stack traces

- So, that's the matrix stack, but we're still stuck in Flatland. Let's try to 
break into the world of three dimensions
    - Let's add our 'z' coordinate, coming out of the page toward us, with y 
    axis still going up and the x coordinates going right
        - This is a RIGHT-HANDED COORDINATE system, probably coming from the 
        right-hand rule, with the thumb on the x-axis and your index finger on 
        the y-axis
            - It's perfectly okay to have the z-coordinate going into the page, 
            of course - but that's a left-handed system
- Now, for our 3D vectors, we'll need to actually add a 1 to the bottom to make 
it homogenous, just like we did in the 2D case. For instance:

        P = [x, y, z, 1]

    - Similarly, to make our transformation matrices homogenous, they have to 
    be 4x4:

        [1 0 0 dx]
        [0 1 0 dy]
        [0 0 1 dz]
        [0 0 0 1 ]

- The final bit of weirdness comes from rotating in 3D. Trying to rotate just 
around one of the axes is normal - for instance, to rotate counter-clockwise 
around the Z-axis (looking from the direction toward the origin):

        Rz =    [cos  -sin  0  0]
                [sin  cos   0  0]
                [0     0    1  0]
                [0     0    0  1]

    - Similarly, for the other axes,

        Rx =    [1   0   0    0]
                [0  cos -sin  0]
                [0  sin  cos  0]
                [0   0    0   1]

        Ry =    [cos  0  sin  0]
                [0    1   0   0]
                [-sin 0  cos  0]
                [0    0   0   1]

        - "Ry probably looks weird, but the reason is because its 2x2 rotation 
        columns are SWAPPED compared with the other matrices - think of it that 
        way, and it makes more sense"
    - "Remember, you're going to be implementing these in project 1 - so if 
    you've got questions, fire away"
- Trying to rotate around an arbitrary axis, on the other hand, is a little 
weirder...but we'll get to that

- So, that's 3D, but we have a problem: all of our display devices are 2D flat 
panels! So, we somehow squash our 3D objects into a sensible 2D representation
    - To do this, we need to "project" our objects onto the screen, and there 
    are 2 common ways of doing it:
        - PARALLEL PROJECTION (or "ORTHOGRAPHIC" projection) is where we 
        pretend we have a rectangular "view plane" grid of pixels, representing 
        the screen, and each of the pixels sends out a parallel "projector 
        line" straight ahead - and then it draws whatever it hits first
            - This is nice and convenient - but it's NOT how our eyes work, 
            sadly
        - PERSPECTIVE PROJECTION means that instead of shooting all the rays 
        straight ahead, we instead shoot them out at an angle, emanating out 
        from some point called the "center of projection"
            - Realistically, what this means is that objects that are farther 
            away seem smaller - which is great!

- On Friday, we'll dig into the math behind how we can do these projections - 
stay well till then!

</pre>
</article>
<a class="side-link is-note-link" href="5_projectionBasics_1_18_19.html"></a>
</main>
</body>
</html>