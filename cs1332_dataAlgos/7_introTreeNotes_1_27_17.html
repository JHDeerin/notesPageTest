<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/wrapText.js"></script>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Data Structures / Algorithms</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li class="active-note-page"><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="6_recursionNotes_1_25_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre id="text-width-ruler"></pre>
<pre class="main-note-text">//************************************************************//
//********* Intro. to Trees - January 27th, 2017*************//
//**********************************************************//

-Well, we've gone through "Don't Stop Me Now" and are on to the MJ tracks...this show needs to get on the road
------------------------------------------------

-So, Linked Lists, Stacks, Queues...they're nice, sure, but TREES are where data structures get real
    -All of these other data structures have been linear; trees can go in multiple directions
        -*technically you can imagine the other structures as 1D trees, but that's just getting cheeky
    -Their fundamental idea: how to move through information
-REMEMBER: Trees are a SET of data structures, with many types of sub-trees (binary trees, BST's (WHICH ARE NOT JUST BINARY TREES), AVL trees, etc.)

-So, in CS, a TREE is "an abstract model of a hierarchal structure"; they're an ADT that consists of nodes with a parent-child relationship
    -By this definition, a Linked List is *technically* a tree
-Trees are "limited graphs"; aka, they have NO cycles; they have a fundamentally recursive structure (i.e. branching)
-Some applications:
    -File Systems
    -Organization charts
    -Anything your puny mind can imagine!

                |
                /\
               /  \
              /    \
             /\    /\ (...it's too hard to draw an ASCII tree :/ )

-In this class, FOR OUR PURPOSES, we will assume there are no duplicate nodes in a tree when dealing with non-numerical data (when dealing with integers, though...wellllll...)

-IMPORTANT TERMS:
    -ROOT NODE:
        -The node where you enter the tree; it does NOT have a parent, and is almost always on the top of the tree
    -INTERNAL NODES:
        -A node with at least one child node
    -LEAF NODES (aka "External" nodes):
        -Nodes with no children; usually at the bottom of a branch
    -PARENT (of a node):
        -Node immediately above another node
    -ANCESTOR NODES:
        -All of the parents, grand-parent, great-grandparents, etc.,, of a node
    -CHILDREN (of a node):
        -The node(s) IMMEDIATELY below a node (just 1 level down)
    -DESCENDANTS (of a node):
        -The children, grandchildren, great-grandchiltren, etc. of a node
    -"Height" (of a node):
        -The # of nodes that need to be traversed to reach a leaf node/the end of a branch; in this class, we count from "bottom-up," so the height of a leaf node is 0
            -If an internal node has a child that's a leaf, but a non-leaf child, then we count the height as if it's counting up from the non-leaf child (aka, always takes the higher #)
    -"Depth" (of a node):
        -The reverse of height, this is how many nodes you need to go up to reach the root node. IN THIS CLASS, THE "DEPTH" OF THE ROOT NODE IS 1 (yes, 1, NOT 0!!!); we count from "top-down"
            -Depth is the "level" of the tree; height talks about "what's below me?" for a node
    -SUBTREE:
        -A tree within the tree consisting of a node and its descendants
            -Can be any possible subtree within the tree (including the original tree, which is technically a "subtree" of itself)

-So, what methods will you find in pretty much EVERY tree?
    -Generic methods:
        -int size(): returns the size of the tree
        -boolean isEmpty()
        -Iterator iterator():
        -Iterable positions()"

    -Accessor methods (getting a node):
        -position root():
        -positions parent(p):
        -Iterable children(p):
        -int numChildren(p):

    -Query methods (get infrmation about the node):
        -boolean isExternal(p):
        -boolean isInternal(p):
        -boolean isRoot(p):

-NOTE: Trees are recursive data structures due to the way they "branch"; because of this, basically EVERY operation done on the tree (searching, adding, removing, etc.) is handled as a recursive method; while it is SOMETIMES possible to do this iteratively, usually these implementations are messier, more error-prone, and often more inefficient than just writing it recursively

-BINARY TREES are an ADT type of tree where each node has AT MOST 2 children (a left/right child)
    -Can think of the children as an "ordered pair"
    -A binary tree contains a single root node with an ordered pair of children (which are themselves the root nodes of binary sub-trees)
-Applications:

-Some notation: n = # of nodes; e = # of external nodes; i = # of internal nodes; h = height
-BT Properties:
    -e = i + 1
    -h &lt;= i
    -n = 2e - 1
    -e &lt;= 2^h
    -h &lt;= (n-1) / 2

-BT's inherit all of the methods of a normal Tree ADT, but also has three methods for each node:
    -position left(p)
    -position right(p)
    -position sibling(p)

-A BINARY SEARCH TREE is a special case of a Binary Tree, where the LEFT CHILD is ALWAYS smaller than the parent node, and the RIGHT CHILD is ALWAYS LARGER than the parent node
    -What happens to equal items? Well, that depends on the implementation
-So, the left subtree contains ONLY items smaller than the root node, and the right subtree contains ONLY items larger than the root node
    -You might ask, "well, what if we end up with a tree where everything is on one side? Wouldn't that be inefficient, since its basically just a linked list then? Could we fix that problem?" Just you wait...
-A BST is "BALANCED" when all of its leaf nodes (or at least as many as possible) are on the same level
    -In general, BST's can be REALLY out of whack and unbalanced without too many problems

-TREE TRAVERSALS-
    -A TRAVERSAL visits all of a tree's nodes in a systematic order
    -For ALL trees, you can perform a "pre-order traversal" (visit node, then visit all of the left children, then visit all of the right children), a "post-order traversal" (), and a "level traversal"
        -"Pre" because you visit ALL of the left-most nodes first, "post" because you visit ALL of the right-most nodes first...
        -Level traversals just go down row-by-row (breadth-first search?)

-We'll talk about this in more detail on Monday!
</pre>
</article>
<a class="side-link is-note-link" href="8_treeTraversalNotes_1_30_17.html"></a>
</main>
</body>
</html>