<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>(*TEST PAGE*) Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#">Data Structures / Algos.</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li class="active-note-page"><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="4_stackNotes_1_20_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre>//********************************************************************//
//***************Queues - January 24rd, 2017 ************************//
//******************************************************************//

-*REALITY CHECK! Implement a "Stack Class" based on the given interface (on 
website)!*

public class Stack&lt;T&gt; implements StackADT&lt;T&gt; { //almost forgot the &lt;T&gt;'s
    private final int INITIAL_CAPACITY = 100;
    private T[] backing; //had to look up how to declare a generic array
    private int size;

    public Stack() {
        backing = (T[]) new Object[INITIAL_CAPACITY];
    }

    public void push(T item) { //adding/removing from the back is most efficient
        if (size == backing.length) {
            throw new RuntimeException("Stack backing structure is full");
        }
        backing[size] = item; //could've used "size++" here to avoid the 2nd 
        line
        size++;
    }

    public T pop() {
        if (isEmpty()) {
            throw new java.util.EmptyStackException("No objects in stack to 
            return");
        }
        temp = backing[size];
        size--;
        return temp;
    }

    public boolean isEmpty() {
        return size == 0;
    }
}

-...well, that's a bit of a long intro.
    -On the bright side, my implementation was correct!
        *almost; I declared the generic array wrong at first (it's fixed here)

-"This is more or less how test questions will be phrased" - HB
-Speaking of which, 1st test will be IN TWO WEEKS!!!
    -A practice exam will be given, but answer keys will NOT be provided; 
    you'll have to look up the answer for yourself
    -Exam is designed to be finished in 50 minutes (*stunned shock*)
------------------------------------------------------------

-A QUEUE is a FIFO ("first-in, first-out") data structure- the OPPOSITE of a 
stack
    -Just like a normal "queue", or waiting in line: the 1st person to wait in 
    line should be the first to get out!
    -Insertions are at the BACK of the queue, removals are from the FRONT
        -You shouldn't be accessing ANY other part of the Queue
    -Like "Stacks", Queues are considered ADTs, and are fundamentally linear

-MAIN OPERATIONS:
    -"enqueue(object)" inserts an element at the end of the queue
    -"object dequeue" removes and returns the element from the start of the 
    queue
        -Usually also has a "first()" method to look at the front without 
        removing it, as well as a pretty size() / isEmpty() method

-Using an Array as a backing structure:
    -Use an array of size "n", and WRAP AROUND in a circular way
        -When the queue has fewer than "n" elements, "back = (front + size) % 
        n" is the first empty slot past the rear of the queue
            -Elements are ONLY shifted when "enqueueing"; when you remove front 
            elements, you instead change WHERE THE FRONT INDEX is, NOT shifting 
            things
                -This is why you need the "back = (front+size) % n" operation; 
                when you have open space in the front of the queue, you instead 
                add elements to the front of the array and just start the 
                traversal from the "new" front of the array
                    -e.g. the word "AWESOME" becomes "SOMEAWE", but we start 
                    reading from "A" and then wrap around to read; ta-da!
                -This is great, since in return for this "confusion", we avoid 
                having to resize the array for additions! It's therefore MUCH 
                more efficient!
    -2 variables: "front" keeps track of the front/first element, "size" keeps 
    track of the size of the queue

-PSEUDOCODE:
    void enqueue(o)
        back = (front+size) % n
        item[back] = 0
        size++

    object dequeue()
        item = arr[front]
        front = (front + 1) % n
        size--
        return item

        -Now, what would you do if the queue is empty? Throw an error? Return 
        null? It all depends on what you need...

-Linked List Implementation
    -NEEDS a tail variable now to have any sort of efficiency

-PERFORMANCE:
    -Space used is O(n)
    -Time for enqueueing/dequeuing is O(1)

    -Limitations:
        -For array-based implementations, We must either know the initial size 
        OR have to deal with resizing the array (which is O(n), although 
        enqueueing is still considered O(1))
        -Linked List implementations do NOT have this limitation

-Applications:
    -DIRECT-
        -Waiting lists (literally)
        -Printer queues, shared resources, etc.
        -Multithreading

    -INDIRECT- (on the slides)


</pre>
</article>
<a class="side-link is-note-link" href="6_recursionNotes_1_25_17.html"></a>
</main>
</body>
</html>