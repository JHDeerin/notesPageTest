<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Data Structures / Algorithms</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li class="active-note-page"><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="5_queueNotes_1_23_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre class="main-note-text">//****************************************************************//
//**************Recursion - January 25th, 2017*******************//
//**************************************************************//

-AV difficulties, as per usual...well, okay, not THAT usual, but Tech and AV 
problems go together like planes and turbulence
-Go to the career fair! It's good for you! Eat your social-economic fruits and 
veggies!
---------------------------------------------------
-So, the next data structures we'll be talking about are TREES! BUT, before we 
go into those, we need to have a solid grasp of...

-RECURSION: a programming process where, most basically, a method calls itself 
REPEATEDLY until a defined end point
    -A failure to exit will cause an infinite loop, which will cause a crash, 
    which will cause tears

-Probably the most classic "pedagogical example" of recursion, in 
Math/CS/Advanced Cookery classes, is with factorials
    -"n = 1*2*3*...*n"
    -Recursive definition:
        f(n) = 1) 1, if n == 0
               2) n * f(n-1), otherwise
        -In good ol' Java:
            public int factorial(int n) {
                if (n == 0) {
                    return 1;
                } else {
                    return n * factorial(n - 1);
                }
            }

-Side Note: Computers now handle infinite loops MUCH more gracefully. In the 
paper-punch days, an infinite recursive loop would...well...it wasn't pretty 
(especially since you had to pay for operations by the minute, and they tended 
to run for a WHILE)

-EVERY recursive method has to have a way of eventually reaching a terminating 
condition, no matter the input
    -this "terminating condition" is also called the "BASE CASE"; when it is 
    reached, the method does NOT call itself again, but returns control to the 
    previous method call (i.e. whatever called it)
        -There can be multiple base cases in a method, or multiple ways of 
        reaching it, as long as it meets the criteria that it WILL END 
        eventually (w/o catastrophic failure, like a memory crash, the computer 
        rusting away, wild axe attacks, etc.)
        -Also, while you usually do, you do not HAVE to return something in a 
        recursive method
-Behind the scenes, recursive calls are kept track of using a stack

-Another example of a recursive method: BINARY SEARCH
    -It searches an ORDERED LIST for an element by cutting the list in half 
    over and over to find it
        -Initially, low = 0, high = length - 1
    -PSEUDOCODE (for searching integers):
        binarySearch(dataset, targetObj, low, high) {
            if (low &gt; high)
                return false
            else
                mid = (low + high)/2;
                if (targetObj == data[mid])
                    return true
                else if (target &lt; data[mid])
                    return binarySearch(data, targetObj, low, mid-1) //could 
                    floor/ceiling, doesn't matter if done properly
                else
                    return binarySearch(data, targetObj, mid+1, high)
        }
        [Example] Searching for "6":
            |1   2   3   4   5|
            1   2  |3   4   5|
            1   2   3   4   |5|
            1   2   3   4   5||
            return false
        -2 terminators: if the low/high indices pass each other (have searched 
        the entire list), OR if we find the target
        -Runs in O(log n) time, which is MUCH better than a linear search
            -Initially searching area in list of size "high - low + 1", which 
            is cut in half each times

-Another function that can be defined recursively is exponentiation, i.e. the 
"power" function
    - P(a, n) = a^n
    -Recursively: P(a, n) = 1) 1, if n == 0
                            2) a * P(a, n-1), otherwise
        -In Java, the Most Highly Esteemed Steamed Coffee:
            int power(a, n) {
                if (n &lt; 0)
                    return a / power(a, n+1);
                if (n == 0)
                    return 1;
                return a * power(a, n-1);
            }
        -This version runs in O(n) time, and is quite clear to understand...
        -...but WE CAN DO BETTER
    -Recursive squaring! :
        -P(a, n) = 1) 1, if n == 0
                   2) a * P(a, (n-1)/2)^2, if a &gt; 0 and a is odd
                   3) P(a, (n-1)/2)^2, if a &gt; 0 and a is even
        -In PSEUDOCODE (on slides):
            power(a, n) {
                if (n == 0)
                    return 1
                if (a % 2 == 1)
                    y = power(a, (n-1)/2)
                    return a*y*y
                else
                    y = power(a, n/2)
                    return y*y
            }

-There's also a special form of recursion called "Tail Recursion"
    -Tail recursion is when EVERY recursive method call is the VERY LAST STEP 
    before returning from the method
        -This helps with optimization, as it means that methods aren't left 
        "hanging" in the call stack waiting to receive something else before 
        they continue
            -Java does NOT optimize for tail recursions; many languages do when 
            compiling, however

-QUICK EXERCISE: Write a recursive method for determining if a string is a 
palindrome ("race car", "wow", "1331", "a man a plan a canal panama")
    //My idea: check repeatedly if the first/last letters match (possibly after 
    removing spaces), then do a recursive call with the first/last letters 
    lopped off (via the substring method)
    public boolean isPalindrome(String s) {
        if (s.length == 1) {
            return true;
        }
    }


</pre>
</article>
<a class="side-link is-note-link" href="7_introTreeNotes_1_27_17.html"></a>
</main>
</body>
</html>