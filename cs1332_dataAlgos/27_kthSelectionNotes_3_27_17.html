<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/wrapText.js"></script>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Data Structures / Algorithms</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li class="active-note-page"><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="26_radixSortNotes_3_17_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre id="text-width-ruler"></pre>
<pre class="main-note-text">//***********************************************************************//
//*******************Kth Selection - March 27th, 2017*******************//
//*********************************************************************//

-Another cloudy, grey, HB-less day...
    -...and the TAs are (semi)frantically trying to figure out what we did before spring break
    -ALSO: welcome back from spring break!
-NEVER MIND! HB just arrived
----------------------------------------

-One last "sort" we might as well go over: "Kth-Selection" (aka QUICK-SELECT)
    -Let's say that we want to find the 5th smallest # in the array; to do this, we DON'T have to sort the whole array and then choose the 5th element
        -Instead, kind of like Quick Sort, we choose a pivot, move all the larger/smaller items to the left/right, and then swap the pivot to its correct, FINAL position (EXACTLY like in quick-sort)
            -This is known as the "prune-and-search" paradigm, btw
        -We then CHECK the INDEX of the pivot
            -If it is EQUAL to "k - 1," then we've found the kth smallest (since the pivot is in its final position, and we start counting from 0 (so 1st smallest # will be at position 0, etc.))
            -If it is LESS than "k-1," we look in the right half of the list and start again
            -If it is GREATER than "k-1," we look in the left half of the list and start again

    e.g. suppose we're looking for the 1st smallest (k = 1):
    -First, let's choose a pivot:
        [33, 14, 7, |21|, 22, 40, 19]
    -Now let's go through the quick-sort partitioning process
        [21| 14, 7, 33, 22, 40, 19] -&gt; [21| 14, 7, 19, 22, 40, 33]
            -&gt; [19, 14, 7, |21|, 22, 40, 33]
                0   1   2   3    4   5    6
    -Now, the pivot is in it's final position at index 3; 3 &gt; (1-1 = 0), so let's look on the left side
        [|19|, 14, 7] -&gt; [7, 14, |19|]
                          0   1    2
    -Pivot at 2, so let's continue on the left side
        [14, |7|] -&gt; [7, 14]
                      0   1
    -7 is now at the 0 index, and 0 = k - 1, so, 7 is the 1st smallest #! We've found it!

    -Another example (this time OUT-OF-PLACE, which requires us to change k):
        -when k = 5
            [62, 10, 47, 25, |18|, 81, 44, 49, 96]
                -&gt; [10, |18|, 47, 25, 62, 81, 44, 49, 96]
                    0     1    2   3   4  5    6   7   8
        -Now, 1 &lt; (5-1 = 4), so we're going to look in the right part of the array
            -So, our new array we're looking at is:
                [47, 25, 62, 81, 44, 49, 96]
                 0   1   2   3   4   5   6
            -HOWEVER, since it's out of place, we now call "k-select" with a new K, so the "k = k - (pivotIndex + 1)" -&gt; "5 - 2 = 3"
                -Notice how the element at the 5th index in our old array (81) is the SAME one at the 3rd index in our new array; this is WHY we change K, because we can conclude that the 5th smallest element in the whole array is now only the 3rd smallest element in the new array
        -So, if we continue through all these steps, we'll end up with the right answer!

-What's the efficiency of Kth-Selection / Quick-Select? Well, it has a best/average case performance of O(N)
    -This is significantly faster than sorting; GREAT!
    -However, it is based on Quicksort, so it has a worst-case runtime of O(n^2)
        -T_T
        -(...this only has like a (1/n)^n chance of happening though, so practically it's only a concern in the same way engineers kind of HAVE to worry about a hurricane striking Canada)

-So, on Wednesday we'll leave the wide, wide world of sorting for a brand-new topic: String Searching!
    -Specifically, we'll look at brute-force searching, and then get to the exciting stuff: the Boyer-Moore Algorithm
</pre>
</article>
<a class="side-link is-note-link" href="28_stringSearchNotes_3_29_17.html"></a>
</main>
</body>
</html>