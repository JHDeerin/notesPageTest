<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Data Structures / Algorithms</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li class="active-note-page"><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="0_firstDayNotes_1_9_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre class="main-note-text">//********************************************************************//
//**************Arrays &amp; ArrayLists - January 11th, 2017*************//
//******************************************************************//

-Well, any class starting with the Pokemon theme song can't be too bad!
-"Saikrishna Slides" (PowerPoint presentations from past TA) are available on 
T-Square
-------------------------------------------------------

-NOTE: "Big-O" notation CAN refer to how much space/memory an algorithm 
utilizes; THIS IS NOT THE DEFINITION WE USE
    -In THIS course, BIG-O notation is an "algorithmic complexity" measure of 
    the WORST-CASE RUNTIME for a particular algorithm
        -e.g., O(n), O(nlog(n)), O(n!), etc.
    -Determined by the degree of the polynomial; O(2n) is still considered 
    O(n), since it runs in linear time

-So, an ARRAY is a sequenced collection of variables, ALL OF THE SAME TYPE; 
each variable is called a CELL, and each "cell" has an index that marks its 
location (0, 1, 2, 3, ...)
    -The value stored in an array's cell is called an "element" of the array
    -If you know the index, accessing a particular element takes O(1)
-FOR AN ARRAY, THE CAPACITY DOES NOT EQUAL THE SIZE!!!
    -"Capacity" is the length of the array, INCLUDING null / empty cells
    -The "Size" is the number of elements within the array (check this???)
        -Confusingly, the Java ".length" variable actually gives you the 
        capacity :(

-So, we can declare an array in a few ways:
    -Array "literal" method: int[] array = {1, 2, 3, 4}; //literally just list 
    elements
    -Declaring it's size, then filling it: int[] array = new int[10];
-Array can store Primitives, OBJECTs, OR References to objects
    -Pretty versatile! BUT, Arrays have one big downside: They're completely 
    static (i.e. can't be resized)

-ARRAYLISTS, on the other hand, CAN be resized, but CAN ONLY STORE OBJECTS 
(primitives are converted via "wrapper classes")

-Arrays can be used as a "backing structure" for the list; when it fills up, 
the array is resized by creating a new, larger-capacity array, then COPYING all 
of the elements from the old array over (USUAL METHOD; there are other 
possibilities)
    -This copying process takes O(n) time, which is a LOT if you're dealing 
    with large data sets
-To ADD an element to, say, the middle of the ArrayList (index "N"), once we 
have a "Backing Array" with enough space for the new element, we shift ALL of 
the elements in front of the "n" index forward one space, then put the new 
element in the (now-empty) "n" space
    -Runtime-wise, this is O(# elements) + O(1) = O(# elements) = O(N)
    -So, adding something to the front, we have to move EVERYTHING forward
    -Adding to the back, we just put the element at the "back" of the array 
    (the first null cell of the array)

-So, the FULL procedure for adding is:
    if (size &gt;= array.length)
        resize array
    for (i = Size - 1, i &gt; indextoPlace, i++)
        move entry forward one space

-REMOVING an element, we have to move all of the elements in the list BACKWARDS 
to "fill the gap," UNLESS we remove the last element, of course

-So, for an ArrayList:
    -Accessing elements takes O(1)
    -Searching, inserting, or removing from the ArrayList takes O(n) time, 
    UNLESS adding / removing from the back, which takes O(1) time
-ArrayLists are EXTREMELY useful for retrieving information QUICKLYU, but, 
since it takes so much time to resize them, they're NOT that great for 
situations where we're adding/removing elements rapidly ("extensively 
manipulating the data")

-So, ArrayLists perform poorly when we have to rapidly manipulate our data; who 
shall be our knight in shining armor to rescue us from this foul conundrum? How 
about a LINKED LIST!

-"Linked Lists" are composed of "Nodes", each of which has two parts:
    -"Data", which contains all of the "useful information" for the node (e.g. 
    the object stored there)
    -A pointer "next" to the next LinkedList

    -node example:   |-DATA | NEXT-|--&gt;

    -example of the chain:
        |10| -|--&gt; |5| -|--&gt; |17| -|--&gt;

-HOWEVER, we have nothing pointing to the first element, so let's have a 
reference/pointer to the first LinkedList called "HEAD", so we can access the 
LinkedList via the first element
    -We know we're at the end of the list when the "next" pointer is null

-So, we have to go through the WHOLE LinkedList to access an element, so 
getting an Element is O(n) - WORSE than ArrayLists
-Searching takes O(n), which is the same as an ArrayList...
-...BUT, ADDING a node to the front of the LinkedList is done by just creating 
a new Node, having it's "next" reference point to the FIRST node (the "HEAD"), 
then having it become the first node by having the HEAD variable point to it 
instead
    -This is CONSTANT TIME: O(1)!!!! (1 unit of time to create the node, 1 unit 
    to redirect the pointer, 1 unit to redirect the head)
    -Keep in mind, of course, this is for adding to the front only
-Adding OR removing to the BACK, however, takes O(n) time, since we have to 
iterate through the whole list first to find the back :(

-If the HEAD variable is redirected to the new 1st node, which DOESN'T point to 
the old first node, then the linked list will be automatically garbage 
collected, since there's suddenly no way to reach it / no references in the code


</pre>
</article>
<a class="side-link is-note-link" href="2_linkedListNotes_1_13_17.html"></a>
</main>
</body>
</html>