<html>
<head>
<title>(*TEST PAGE*) Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#">Data Structures / Algos.</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li class="active-note-page"><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="19_splayTreeNotes_2_27_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre>//***************************************************************//
//*****************B Trees - March 1st, 2017********************//
//*************************************************************//

-Exam is in ONE WEEK (AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH)
-Don't be a child and complain if TAs take a week to grade homework...
-Don't whine for exam topics when it's on the syllabus...
    -...apparently these are actual issues on Piazza?
-"If you thought AVLs were bad, wait till you hear about 2-4 trees"
    -...2-4 trees WILL be on the exam!
--------------------------------------------------

-B trees are similar to BSTs, but with one HUGE difference: each node can hold 
MULTIPLE DATA ITEMS
-The "order" of the B-Tree describes how many data items/children the node can 
have
    -e.g. If the "order" of the B-tree is 5, that means each node can have up 
    to 5 children, and each node can have 4 (5-1 = 4) data items
        -Order is based on # of children
        -THE AMOUNT OF DATA EACH NODE CAN HOLD IS (Order - 1)
    -Data in children will be ordered "least to most"
-B-Trees DO have balancing, but it's different from AVL balancing

-We will be focusing on 2-4 TREES; these are a subtype of B-Trees that have an 
order of 4
    -i.e., each node can hold up to 3 pieces of data, w/ up to 4 children
-The data items WITHIN each node are stored in ASCENDING order (least -&gt; 
greatest)
-The first child is less than the first data item, the 2nd child is between the 
first/second data item, the third child between the 2nd data/3rd data, etc.

                        [x y z]
                       /  / \  \
                      A   B   C  D

    -All data items in node A are less than X, everything in B is between X and 
    Y, everything in C is between Y and Z, and everything in D is greater than Z
    -"[]" is the node, "x y z" are the data elements in "[]"

-In a B-Tree, the depth of ALL leaf nodes is the same
-If there are "n" data items in a node, then there must be either 0 OR "n+1" 
children
    -BECAUSE of these rules, a B-Tree will ALWAYS be balanced, and 
    searching/adding/removing from a B-Tree will ALWAYS be O(log n)

-SEARCHING is done by
    -Starting at the root
    -Compare the first data item in the node w/ what you're searching for
        -If the data you're looking for is LESS THAN that 1st data in the node, 
        then go to the "nth" child, where "n" is the position of the data in 
        the node
        -If the data is equal, hey, you've found the node! Exit and give 
        yourself a cookie

-PSEUDOCODE-
    search (data, node)
        if node == null
            return false
        else
            for (i = 1, i &lt; n, i++)
                if data == node.data[i]
                    return true
                else if data &lt; node.data[i]
                    child = node.getChild(i)
                    return search(data, child)


-When ADDING to a B-Tree, the new data item is ALWAYS added to a leaf node, not 
to an internal node
-We follow the same steps as searching until we find the data in the tree, or 
reach a leaf node...
-Then, if the data is NOT in the tree (i.e. we're at a leaf), then we add the 
data to that leaf node
    -If the data IS in the tree, then we can do a few different things 
    depending on implementation. We might do nothing, we might replace the 
    existing data, we might panic and trigger an emergency disco sequence, etc.
-OVERFLOW- after the data is added to a leaf, the node might have too many data 
items for the type of tree (e.g. for a 2-4 tree, we can only have a max of 3 
data items, but after adding we might have 4)
    -If this is the case, the MIDDLE item (in a 2-4 tree, either the 2nd or 3rd 
    node) is "promoted" to be the parent of the existing node; then, we SPLIT 
    the existing node into a left half (the data values less than the 
    "promoted" one) and a "right half" (the data values greater than the 
    promoted node)
    -HOWEVER: If the parent node ALREADY exists and has room for another data 
    item, we instead move the "middle" data item to the existing parent instead 
    of creating a new one
        -WE STILL SPLIT THE CHILDREN IN THE SAME WAY, however
    -If the parent node DOESN'T have room for another element, WE STILL MOVE 
    THE MIDDLE ITEM TO THE PARENT, then recursively call "Overflow()" on the 
    (now-overflowing) parent!
        -Sometimes when doing this, we end up with a node with 5+ children 
        (i.e. more children than we're allowed), meaning we have to split up 
        the children again, with all of the nodes less than the removed 
        "middle" node becoming children of the left child, and all of the node 
        greater than it becoming children of the right child...

-PSEUDOCODE-
    add(data, node)
        for (i = 1, i &lt; n, i++)
            if (data == node.data[i])
                //do something w/ duplicate
            else if (data &lt; node.data[i])
                if node.numberOfChildren() &gt; 0
                    child = node.getChild(i)
                    add(data, child)
                    if (child.numItems &gt; 3)
                        break child into 2 nodes, promote "middle" item
                    return
                else
                    add data to "ith" position in this node
        if (node.numberOfChildren() &gt; 0)
            child = node.getChild(i)
            add(data, child)
            if (child.numItems &gt; 3)
                break child into 2 nodes, promote "middle" item
            else
                add "data" to last spot in this node

-With REMOVING, it actually gets even messier...but we'll get to that on 
Friday. READ SAIKRISHNA SLIDES TO PREPARE


</pre>
</article>
<a class="side-link is-note-link" href="21_moreBTreeNotes_3_3_17.html"></a>
</main>
</body>
</html>