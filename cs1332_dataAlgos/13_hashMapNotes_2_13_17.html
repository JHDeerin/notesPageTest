<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>(*TEST PAGE*) Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#">Data Structures / Algos.</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li class="active-note-page"><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="12_moreHeapNotes_2_10_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre>//***************************************************************//
//********Intro. to Hashmaps - February 13th, 2017**************//
//*************************************************************//

-Exam 1 grades should be back!
-BST homework is due tonight!
    -"If you haven't started yet, well, good luck to y'all..."
----------------------------------------------------------

-So, we've talked about queues, lists, stacks, trees, heaps...
    -Some of these don't really compete with each other (e.g. heaps are VERY 
    specialized); others have various trade-offs with each other

-We've had LISTS
    -LINKED LISTS are great for rapidly adding stuff, but are poor at random 
    retrieval
    -In contrast, ARRAYLISTS are awesome at random retrieval, but can be slow 
    to add stuff to

-We've had TREES (which we'll come back to, since there's a metric ton of these 
things)

-A "SET" is a collection of unique objects
    -Technically, your BST homework fits this definition, since we didn't allow 
    duplicates to be created
-A "MAP" is a type of set where every item (the "key") is pointing to a unique 
value ("value")
    -This "key-value" pairing is quite useful; ALL of the keys are unique in a 
    map, but values don't necessarily have to
    -examples:

-Today, we'll be talking about a special type of map: the HASHMAP
    -This is NOT an ADT; a "Map" is an ADT, but the HASHMAP is a specific 
    implementation of a map

-A HASHMAP is AWESOME because you get O(1) runtimes for almost EVERYTHING: 
adding, searching, etc.,
    -"Wow, that sounds amazing! How do we do this, and why don't we use this 
    all the time?" Well, we'll answer both questions...
-So, in an array, we can access anything INSTANTLY in O(1) time IF we know the 
item's index (i.e. it's memory address); a "Hashmap" takes this idea and runs 
with it
    -In Java, EVERY OBJECT has a "hashCode()" method that returns an integer 
    that "should" be unique to that object
    -A "Hashmap" basically uses this unique numbering for the object to put the 
    object in a giant array, where we put it in it's "hashCode" index; we then 
    use the "hashcode" calculation to find it's index again and access it!
        -Of course, you would need to have enough information to recalculate 
        the "hashcode" anyway, but that's a practical implementation problem, 
        and we're just teaching the basics

-EXAMPLE: for a "Person" object, we could have a hashCode where we "return 
personAge;", and store each person at the index equal to their age

-Now, there are some problems with this; for instance, let's say our "Hashmap" 
only has a length of 10, and we're trying to add something with a hashcode of 
11; what can we do?
    -Well, we could use a COMPRESSION FUNCTION to fit the hashcode into our 
    backing array; for instance, we could (and usually do) just use modulus to 
    make sure the hashcode is ALWAYS a valid index
        -e.g. index = hashcode % arraySize;

-What if 2 objects share the same hashCode, or if the "compression function" 
tries to store 2 objects in the same array index? This is known as a COLLISION, 
and it's the most common problem with a hashMap
    -One thing we COULD do is have the backing array be an array of 
    linkedLists; this way, if we try to add 2 things to the same index, we just 
    end up with a LinkedList of size 2 at that index; then, when we search at 
    that index, we just have to search through the (probably very small) 
    LinkedList to get the object
        -This is known as EXTERNAL CHAINING, and a lot of the time, it works 
        just fine!
        -The PROBLEM with this, of course, is that if we end up with a BUNCH of 
        collisions, then we could theoretically end up with a search time of 
        O(n) (if everything gets stored in the same index, because you're inept 
        at making hashCodes or something)
            -You don't HAVE to use linked lists, by the way (Java's 
            implementation uses AVL trees, for example)
    -So, the efficiency of a hashMap is VERY dependent on the quality of it's 
    hashCode
        -by "quality" here, we mean the ability for the hashcode function to 
        create UNIQUE, non-colliding hashCodes for each object

    -Another technique we could try is LINEAR PROBING, where when we have a 
    collision, we move forward "i" spots until we find an open index
        -Now when you're doing this, you have to be VERY careful with 
        retrieval, because it means that when you access an index you can't 
        automatically assume it's the object you're searching for; you have to 
        keep moving forward and checking for your object until you find it
            -This technique is actually pretty similar to "external chaining;" 
            we're just storing the extra collisions in the hashMap itself 
            instead of an external list
        -The PROBLEM with this technique, though, is that the more collisions 
        we have, the more open spots we fill up, which makes collisions MORE 
        likely to happen over time; i.e., "Probing" has the problem of making 
        hashmaps get WORSE performance over time
            -Chaining isn't a whole lot better, but it does keep things more 
            contained, which means that if one index gets a lot of collisions 
            it doesn't screw up other parts of the hashmap
-Basically, Chaining vs. Probing is a question of runtime efficiency (chaining) 
vs. less space/memory usage (Probing)

-Is there a better way to do this? Well, like with an ArrayList, one thing we 
could just do instead is to GROW THE BACKING ARRAY
    -To do this, we set some threshold, e.g. "67%"; when more than "67%" (or 
    whatever %) of the spaces in the backing array are filled, then we resize 
    the backing array
        -This threshold is known as the LOAD FACTOR of the hashMap
        -In this class, we tend to resize to 2n + 1, just because
        -You STILL RESIZE when using chaining, since this still affects 
        performance
    -Now, unlike in a normal ArrayList, we have an issue here: how do we copy 
    the data over? If we just copy over all of the data over, then the 
    COMPRESSION function will mean that some items are at the wrong index!
        -e.g. If our old array's capacity was 10 and we added something with 
        hashCode "11," then the compression function would've put it at index 1 
        in our old array
    -So, when we're copying everything over to the new, larger array, we have 
    to RE-HASH EVERYTHING to make sure it ends up in the right spot!

-So, the thing about hashMaps is that even though you "theoretically" have O(1) 
performance for everything, there's a LOT that complicates this: the quality of 
your hash function, the size of your backing array, etc.
    -Realistically, in real-world scenarios with fairly large sets of data, you 
    [CLIFFHANGER *DUN DUN DUN*]

So, performance-wise for hashMaps:

-The WORST-CASE scenario for adding/removing/searching/accessing is O(n), if we 
end up ALWAYS colliding (because we're idiots) and end up having to search 
through everything
    -This is the same for linear probing AND chaining

-Now, there's another type of "resolution strategy" for collisions that we can 
try: QUADRATIC PROBING
    -In this technique, after finding the first open space "i" spaces away, we 
    SQUARE i first, then add the item to index "[hashcode] + i^2"
        -Why does this help? It SPREADS OUT THE COLLIDING OBJECTS, which means 
        that we're not as likely to "bunch up" objects
        -Overall, it has a similar performance as the other strategies, but 
        degrades the performance a LOT less over time than normal probing


</pre>
</article>
<a class="side-link is-note-link" href="14_moreHashMapNotes_2_15_17.html"></a>
</main>
</body>
</html>