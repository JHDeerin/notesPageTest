<html>
<head>
<title>(*TEST PAGE*) Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#">Data Structures / Algos.</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li class="active-note-page"><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="29_moreStringSearchNotes_3_31_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre>//************************************************************************//
//************KMP String Searching (cont.) - April 3rd, 2017*************//
//**********************************************************************//

-SIDE-NOTE: Some implementations of MSD Radix sort are unstable; if you add to 
the front of the bucket, it will be unstable, if you add to the back (aka, 
normally, using queues), it WILL be stable
    -LSD Radix should ALWAYS be stable, though
----------------------------------------

-WARM-UP!
    -"Construct the KMP failure table for:
        pattern: attatca"

    pattern: a t t a t c a
             i           j
             0,0,0,1,2,0,1
        -Yup! This isn't a bad example, though; expect something a bit more 
        involved on the test

-So, once we have the failure table, how do we use it?
    -Align the pattern w/ the beginning of the text (like in the other string 
    searches)
    -Compare the first character of the pattern w/ the first character in the 
    text
        -If they match, keep incrementing the index until we reach the end of 
        the pattern, meaning we have a match
        -If they DON'T match:
            1) If the mismatch is on the pattern's FIRST letter, then shift the 
            pattern to the right by one, and restart comparing the 1st letter 
            of the pattern and the current index of the text
            2) If the mismatch is NOT on the pattern's first letter, use the 
            failure table to determine how much to shift the pattern to the 
            right
                -How? Let's say the mismatch was on index "j" of the pattern; 
                then we look at failureTable[j - 1]; the value there tells us 
                the next alignment of the pattern w/ the text, where we

    -More numerically:
        1) if pattern[j] == text[k], and j &lt; pattern.length &amp;&amp; k &lt; text.length,
            then j++, k++
        2) If / when pattern[j] != text[k], and j == 0 (1st char of pattern), 
        then k++
        3) If pattern[j] != text[k], &amp;&amp; j != 0, then j = fT[j - 1]

    -e.g. let's say we have this pattern, with the failure table already 
    generated:
        pattern: t h e a t h a
        fT:      0,0,0,0,1,2,0
    -And this text:
        "the theatha theatheathar"
    -We want to highlight ALL matches, so we'll highlight whenever we have a 
    match
    -We start like this:
        t h e   t h e a t h   t h e a t h e a t h a r
        t h e a t h a
    -j=1, j=2, j=3...then we hit a non-match (the first space)! So, we shift 
    the pattern to spot "k" (which also equals 3) - fT[j - 1] = fT[2] = 0; 3 - 
    0 = 3, reset j to 0, and start again
        t h e   t h e a t h   t h e a t h e a t h a r
              t h e a t h a
    -The first letters (j = 0 &amp;&amp; k = 3) mismatch right away! We shift the 
    pattern right 1 spot
        t h e   t h e a t h   t h e a t h e a t h a r
                t h e a t h a
    -So, we go ALL the way to the end of the string, then have a mismatch when 
    j = 6; fT[6 - 1] = fT[5] = 2 tells us to shift right 6 - 2 = 4 spaces 
    right, ending up with this
        t h e   t h e a t h   t h e a t h e a t h a r
                        t h e a t h a
    -So, we'll start looking at "e" (j = 2), since we know from the failure 
    table that the first 2 characters match, meaning we IMMEDIATELY have a 
    mismatch; j = 2, so we shift right 2 - fT[1] = 2 - 0 = 2 spaces
        t h e   t h e a t h   t h e a t h e a t h a r
                            t h e a t h a
    -From the start, we have a mismatch immediately, so we move right 1 spot 
    (k++) and reset j to 0
        t h e   t h e a t h   t h e a t h e a t h a r
                              t h e a t h a
    -We have a mismatch when we get to "a" in the pattern, so once again, we 
    shift j - fT[j - 1] = 6 - fT[5] = 6 - 2 = 4 spaces right, and we'll reset j 
    to fT[j - 1] = 2, so we'll start looking at "e" in the pattern
        t h e   t h e a t h   t h e a t h e a t h a r
                                      t h e a t h a
    -We get all the way to the end with a match! Let's highlight that match and 
    move the pattern past the match
        t h e   t h e a t h   t h e a t h e a t h a r
                                      * * * * * * * t h e a t h a
    -We're past the end of the table, so we're done!

-So, hopefully that example helped to clarify the rules; there are a TON of 
other examples available if you need them
-We'll briefly go over Raben-Kaarp (??) next time, then head into the last unit 
of the year: Graphs!


</pre>
</article>
<a class="side-link is-note-link" href="31_theLastStringSearchNotes_4_5_17.html"></a>
</main>
</body>
</html>