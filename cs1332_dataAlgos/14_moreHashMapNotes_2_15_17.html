<html>
<head>
<title>(*TEST PAGE*) Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../css/testStyle.css" rel="stylesheet"/>
<link href="../css/notePageStyle.css" rel="stylesheet"/>
<link href="../css/cs1332Theme.css" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#">Data Structures / Algos.</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li class="active-note-page"><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="13_hashMapNotes_2_13_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre>//******************************************************************//
//**************Hashmaps (cont.) - February 15th, 2017*************//
//****************************************************************//

-HB is, per usual, stuck in traffic; TA team to the rescue
------------------------------------------

-So, we talked about best/worst case performance of hash maps, and it's VERY 
dependent on 2 things:
    1) The quality of your hashCode() function
    2) The size of your backing array (larger = better, since it means less 
    collisions)

-So, what makes a good hashCode/"hashing" function? We want to avoid 
collisions, of course, but how can we do that?
    -We NEED the hash function to be reproducible, because it will be used to 
    search for the object later on (so we can't just use a random number or 
    something else)
        -Also means we need to just use the data we'd know about the object to 
        search for it; if we want to search for it just using the name

-Remember ASCII tables? All of those characters are actually just numbers under 
the hood
    -So, one POSSIBLE hash function for strings is to just add together all the 
    values of the characters in the input string!
        -This is better than just, say returning the age of a "person" object,  
        but it STILL has a lot of collisions
            -e.g. "bin" == "nib" == "ibn" with this function
        -Maybe we could multiply the letters by a value depending on their 
        place (e.g. char[0] * 1 + char[1] * 2 + ...) to differentiate them, but 
        this STILL isn't perfect
-The thing about Hash Maps is that even though they're O(1) for everything, 
it's often HARD to write a good enough hash Code to get close to that O(1) 
performance

-So, chaining vs probing: probing will require you to regrow the backing array 
more often than external chaining, but either way, you're going to want to 
start off with a fairly large array
    -Usually, for the table size, we choose a PRIME NUMBER because otherwise, 
    for quadratic probing, we could end up with the index "infinitely cycling" 
    if it's adding the table size to the index (e.g. in an array of size 8, 
    we're trying to move an item to index "i+8" thtough probing; this would 
    just cycle back to the same place, so then we would add 64, which would 
    have the same problem, ...)

-For PROBING, when it's time to remove one of the values, and the value you're 
REMOVING would create a "gap" between the keys in the map that should be at 
that index (e.g. 1, 2, 3 should all be at the same index, and we delete 2)
    -We could just set this to null, but then that could mean that when we add 
    the next thing it gets added FAR away from its original index, resulting in 
    as bad as an O(n) search time
        -Just look up removal on the Saikrishna slides, HB didn't explain it 
        well

-So, when is it good to use a hashMap?
    -Students with unique ID #s
    -

-Adding /Searching/Removing from a hashMap should ALL ideally be O(1) operations
    -In the worst case, if we have a table ENTIRELY made of collisions, then 
    all of these operations can become as bad as O(n)

-DOUBLE HASHING is when, for the hashCode / hashing function, we do TWO 
separate calculations (e.g. "# % 7" and "# % 3") (primes chosen just because it 
reduces the chance of )
    -Normally, we just use the 1st, "normal" hash function; BUT, when there's a 
    collision, we instead use the SECOND hash function, or a combination of the 
    two (e.g. #1 + #2) if the 2nd one ALSO doesn't work
        -Collisions certainly can still happen, but this reduces the chance

-LAST MINUTE AD!!! Some GT Students made a thing called "Internblitz," which 
they're currently marketing as a "Common App for Internship Applications"
    -"You can apply to 15 internships in 5 minutes"
    -"Don't be that kid stuck on CareerBuzz!"


</pre>
</article>
<a class="side-link is-note-link" href="15_skipListNotes_2_17_17.html"></a>
</main>
</body>
</html>