<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - OOP</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../../css/testStyle.css" rel="stylesheet"/>
<link href="../../css/notePageStyle.css" rel="stylesheet"/>
<link href="../../css/cs1331Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../../js/wrapText.js"></script>
<script defer="" src="../../js/pageTransitions.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">OOP</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_classNotes_9_14_16.html">0. Classes</a></li><li><a class="is-note-link" href="1_moreClassNotes_9_16_16.html">1. Classes (Cont.)</a></li><li><a class="is-note-link" href="2_inheritanceNotes_9_26_16.html">2. Inheritance</a></li><li><a class="is-note-link" href="3_moreInheritanceNotes_9_28_16.html">3. Inheritance (cont.)</a></li><li class="active-note-page"><a class="is-note-link" href="4_polymorphismNotes_9_30_16.html">4. Polymorphism</a></li><li><a class="is-note-link" href="5_morePolymorphismNotes_10_3_16.html">5. Polymorphism (cont.)</a></li><li><a class="is-note-link" href="6_objectSuperclassNotes_10_5_16.html">6. The Object Superclass</a></li><li><a class="is-note-link" href="7_moreObjectSuperclassNotes_10_7_16.html">7. Object Superclass (cont.)</a></li><li><a class="is-note-link" href="8_exceptionNotes_10_19_16.html">8. Exceptions</a></li><li><a class="is-note-link" href="9_moreExceptionNotes_10_21_16.html">9. Exceptions (cont.)</a></li><li><a class="is-note-link" href="10_collectionsNotes_10_24_16.html">10. Java Collections</a></li><li><a class="is-note-link" href="11_moreCollectionNotes_10_26_16.html">11. Collections (cont.)</a></li><li><a class="is-note-link" href="12_collectionAlgorithms_10_31_16.html">12. Collection Algorithms</a></li><li><a class="is-note-link" href="13_iteratorNotes_11_2_16.html">13. Iterators</a></li><li><a class="is-note-link" href="14_lambdaNotes_11_4_16.html">14. Lambda Expressions</a></li><li><a class="is-note-link" href="15_hashedNotes_11_7_16.html">15. Hashed Collections</a></li><li><a class="is-note-link" href="16_javafxNotes_11_9_16.html">16. JavaFX Notes</a></li><li><a class="is-note-link" href="17_JavaFXNotes_11_11_16.html">17. JavaFX (cont.)</a></li><li><a class="is-note-link" href="18_test3Review_11_14_16.html">18. Test 3 Review</a></li><li><a class="is-note-link" href="19_recursionNotes_11_28_16.html">19. Recursion</a></li><li><a class="is-note-link" href="20_linkedListNotes_11_30_16.html">20. Linked Lists</a></li><li><a class="is-note-link" href="21_stackQueueNotes_12_2_16.html">21. Stacks &amp; Queues</a></li><li><a class="is-note-link" href="22_closingNotes_12_5_16.html">22. Closing Time</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="3_moreInheritanceNotes_9_28_16.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre id="text-width-ruler"></pre>
<pre class="main-note-text">//**************************************************************//
//**********Polymorphism - September 30th, 2016****************//
//************************************************************//

-Class getting out 20 minutes early! ("This is definitely not so I can have pizza" - Prof. Simpkins)
-Some of the exams are...on the rougher side; if the class AVERAGE is extremely low (under ~70%), the grades will be curved upwards to reflect that; NO ONE'S GRADE will go down as a result of the curve
-Tracing code is essential, which is why it is so heavily tested; you have to be able to think through how a program will run and operate in order to effectively debug, design, or understand the code you write.
-BRIEF OOP DEFINITION: If you have encapsulation, abstraction, inheritance, and polymorphism, congratulations, you're an OOP language!
-In an imperative program, the "state" of the program is just the values held within all of the containers (imperative languages basically just deal with straight-up values and little else)
-Can trace recursive programs via "substitution method"; THE FUTURE IS WAITING!
-----------------------------------

-So, we know how to derive classes from other class definitions, derive interface definitions, etc.; but we're missing the KEY, BEATING HEART of OOP...
-OOP requires data abstraction via classes (encapsulation), inheritance, and "Dynamic method binding" - the last is what allows for POLYMORPHISM,
    -Remember: static = "done at compile time," dynamic = "handled at runtime"

-Class hierarchies represented via UML diagram, w/ arrows pointing towards parent class; higher you go, in general, the more general the concept is (i.e. "Human" &lt;- "Employee" &lt;- "Plumber" &lt;- "Italian Plumber" &lt;- "Mario")
-Polymorphism gives us some specialization

-Let's say we have "HourlyEmployee" and "SalariedEmployee," which both contain a "payOnTheHour" method not found in employee; these methods are EXACTLY the same, and even share the same name
    -This is NOT polymorphic, as the parent "Employee" class does NOT have a "payOnTheHour" method

-Why is this useful? Let's say we need to make a list of employees to keep track of for the company
    -Right now, we need to have a separate array for "HourlyEmployee" and "SalariedEmployee" objects; for instance, if we want to pay them "payOnTheHour," we'd need 2 loops
    -That's not awful...but what if we want to add a new type of employee? What about a "PayOnCommissionEmployee" that is paid differently? We'd need a new for loop and have to fix a lot of code, just to add 1 more employee
    -...so what if we could have a single list? And just call a "pay" method? It would be cleaner, easier to debug, etc.
    -This is what polymorphism lets us do

-We can make the list be a list of "Employee" objects, which is a superclass ALL of these objects inherit from, and add an abstract method "pay" to the "Employee" class
 (so that ALL of the subclasses have to implement their own "pay" method; otherwise, an error could occur if we call pay)
    -Abstract classes:
        -Cannot be instantiated
        -May contain none, 1, or more abstract methods
        -Subclasses MUST provide an implementation for the class, UNLESS they are ALSO ABSTRACT
    -Could've used an interface instead; but, what we gain with an abstract class is that we can have methods that are pre-defined and take advantage of instance variables (interfaces *can* have pre-implemented methods, but they aren't allowed to use variables, as there's no guarantee that the class implementing it will have those variables); ALSO, we can guarantee that each subclass has a certain structure
        -Interfaces still useful, as you can use multiple interfaces; interfaces are also much more flexible, which makes them better suited for rapid prototyping, with inheritance being added once you have a stable structure established
    -So, "Employee" defines the broad features, and then subclasses fill in the details specific to them

-So, now, when the method is invoked on objects in the "Employee"-type array, the method of the dynamic(run-time) type is used (i.e. the subclasses), even though the static(compiled) type is "Employee"

-Polymorphism is used ALL OVER the place in industry, and is one of the most useful aspects of OOP programming since it allows for easy reuse of code
</pre>
</article>
<a class="side-link is-note-link" href="5_morePolymorphismNotes_10_3_16.html"></a>
</main>
</body>
</html>