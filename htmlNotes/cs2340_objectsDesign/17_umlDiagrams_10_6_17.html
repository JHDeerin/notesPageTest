<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Objects and Design</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../../css/testStyle.css" rel="stylesheet"/>
<link href="../../css/notePageStyle.css" rel="stylesheet"/>
<link href="../../css/cs2340Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../../js/wrapText.js"></script>
<script defer="" src="../../js/pageTransitions.js"></script>
<script async="" defer="" src="../../js/loadMathJax.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Objects and Design</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDay_8_21_17.html">0. First Day of CS 2340</a></li><li><a class="is-note-link" href="1_workingInTeams_8_23_17.html">1. Working in Teams</a></li><li><a class="is-note-link" href="2_teamExercise_8_25_17.html">2. NASA Team Exercise</a></li><li><a class="is-note-link" href="3_introToAgile_8_28_17.html">3. Agile Development / Zenhub</a></li><li><a class="is-note-link" href="4_sourceControl_8_30_17.html">4. Intro to Git/Version Control</a></li><li><a class="is-note-link" href="5_gitBranchingGradleIntro_9_1_17.html">5. Git and Gradle</a></li><li><a class="is-note-link" href="6_gradleAndAndroid_9_6_17.html">6. Gradle and Intro. Android</a></li><li><a class="is-note-link" href="7_introToAndroid_9_8_17.html">7. Intro. to Android</a></li><li><a class="is-note-link" href="8_moreAndroidStudio_9_13_17.html">8. Android Studio (cont.)</a></li><li><a class="is-note-link" href="9_introProgrammingParadigms_9_15_17.html">9. Intro to Programming Paradigms/OOP</a></li><li><a class="is-note-link" href="10_OOPDesignUserStories_9_18_17.html">10. User Stories OOP Design</a></li><li><a class="is-note-link" href="11_domainModels_9_20_17.html">11. Domain Models</a></li><li><a class="is-note-link" href="12_moreDomainAndRDD_9_22_17.html">12. Domain Models (cont.) and RDD</a></li><li><a class="is-note-link" href="13_googleCleanCode_9_25_17.html">13. Google Clean Code</a></li><li><a class="is-note-link" href="14_basicAnalysis_9_29_17.html">14. Basic Analysis</a></li><li><a class="is-note-link" href="15_introToArchitecture_10_2_17.html">15. Intro to Software Architecture</a></li><li><a class="is-note-link" href="16_moreSoftwareArchitecture_10_4_17.html">16. Software Architecture (cont.)</a></li><li class="active-note-page"><a class="is-note-link" href="17_umlDiagrams_10_6_17.html">17. UML Diagrams</a></li><li><a class="is-note-link" href="18_classDiagrams_10_11_17.html">18. Class Diagrams (cont.)</a></li><li><a class="is-note-link" href="19_sequenceDiagrams_10_13_17.html">19. Sequence Diagrams</a></li><li><a class="is-note-link" href="20_mapsAndPersistence_10_16_17.html">20. Google Maps &amp; Persistence</a></li><li><a class="is-note-link" href="21_persistenceAndSafety_10_18_17.html">21. Persistence(cont.) &amp; Safety</a></li><li><a class="is-note-link" href="22_contractsAndExceptions_10_20_17.html">22. Contracts &amp; Exceptions</a></li><li><a class="is-note-link" href="23_introDesignPrinciples_10_25_17.html">23. Intro to Design Principles</a></li><li><a class="is-note-link" href="24_graspPrinciples_10_27_17.html">24. GRASP Principles</a></li><li><a class="is-note-link" href="25_codeReviews&amp;Testing_10_30_17.html">25. Code Reviews and Unit Tests</a></li><li><a class="is-note-link" href="26_testingCode_11_1_17.html">26. Testing Code</a></li><li><a class="is-note-link" href="27_moreUnitTests_11_3_17.html">27. More Unit Tests</a></li><li><a class="is-note-link" href="28_moreDesignPrinciples_11_6_17.html">28. More Design Principles</a></li><li><a class="is-note-link" href="29_SOLID_11_8_17.html">29. SOLID Principles (cont.)</a></li><li><a class="is-note-link" href="30_evaluatingDesigns_11_10_17.html">30. Evaluating Good Designs</a></li><li><a class="is-note-link" href="31_moreEvaluatingDesigns_11_13_17.html">31. Evaluating Designs</a></li><li><a class="is-note-link" href="32_UIDesignPrinciples_11_15_17.html">32. UI Design Principles</a></li><li><a class="is-note-link" href="33_packages_11_17_17.html">33. Packages</a></li><li><a class="is-note-link" href="34_metricsDesignPatterns_11_20_17.html">34. Metrics &amp; Design Patterns</a></li><li><a class="is-note-link" href="35_moreDesignPatterns_11_27_17.html">35. More Design Patterns</a></li><li><a class="is-note-link" href="36_exam2Review_11_29_17.html">36. Exam 2 Review</a></li><li><a class="is-note-link" href="37_finalExam_12_4_17.html">37. Final Review</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="16_moreSoftwareArchitecture_10_4_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre id="text-width-ruler"></pre>
<pre class="main-note-text">//****************************************************************************//
//********************* UML Diagrams - October 6th, 2017 ********************//
//**************************************************************************//

- Fall break begins today! Callooh! Callay!
--------------------------------------------

- So, we've made domain models; now let's talk about UML

- "UML" stands for "Unified Modeling Language"
    - In the 1990s, there were a BUNCH of different diagramming methods for OO design, like the Booch method, Rumbaugh's OMT, Jacobson's OOSE Use Cases, etc.
    - In 1994, though, Rational Software decided that there was a market niche for a software design program - so they hired Booch, Rumbaugh, and Jacobson ("The 3 Amigos") to design a diagramming technique they could all agree on. And thus, UML was born
        - "Nowadays, unless you're looking at REALLY old documents, all of the class diagrams you'll see are in UML"
        - (Rational Software was really succesful, by the way - they were eventually bought by IBM, although open source design software has since become wildly popular)

- There are 17 (SEVENTEEN!) different types of UML diagrams, but we're only going to focus on two: Class diagrams, and Sequence diagrams 

- Classes are drawn just like in our domain model boxes; there's a box with the class name, its attributes, and methods
    - "The point of class diagrams, basically, is for us to create the 'stubs' of all our methods and properties"
    - ATTRIBUTES/properties are all written in the following format:

        [visibility name:type]

        -e.g. + studentCount : int
            - We use a "-" sign for PRIVATE variables, and "+" for PUBLIC variables; 
            - ADDITIONALLY, "#" means "protected", "~" means "package"
            - "Generally, the only public stuff are static fields"
        - Can optionally show the default value for the variable:
            "- id:int = 5"
    - For both attributes AND methods, we underline the name to say that it's "static"
    - For METHODS, we typically do NOT show our getters/setters unless they're doing something unusual
        - Methods usually follow this format:

            [visibility methodName(parameters) : returnType]

            -e.g. "+ getName() : String"
        - Parameters are listed the same way as attributes 
            - There's technically 3 kinds of parameters in UML (In, Out, InOut), but Java only supports "In" parameters, so we're just concerned with those
                - "In" means the variable can only be passed in; "Out" means we're returning a value through that parameter (examples are refs in C#), "InOut" means we're doing both
    - One thing that trips people up: package visibility!
        e.g. "~ i:int"
            - Package visiblity means we just write "int i"; we do NOT put "package" in front of the variable in Java!
                - "Common mean test question from me, so watch out!"
    - Another common error: in UML, the variable name comes FIRST, THEN the variable type; in Java, this is backwards!
    - We represent ABSTRACT classes by writing the class/variable name in Italics
        - "If you can't write in italics, like if you're prototyping on a whiteboard, then you can write {abstract} above the class name, or to the right of the variable"

    - To show that something is CONSTANT (or "final"), we write at the end of the line "{readonly}"
        - e.g. "- id:int {readonly}"
... and that covers 99% of the important stuff for individual class diagrams!
    - "There is some specific stuff like how to show enums, etc., but we'll get to that"

- Now that we have our individual class diagrams in nice little boxes, though, how do we represent the relationships between them?
    - "For instance, let's say we have a 'Person' class, and we want to show that the 'Student' class is a subset of 'Person'"
        - To show inheritance, you draw an arrow FROM the subclass pointing TO the parent!
            - "Students ALWAYS get this backwards; the arrow should be pointing TOWARDS THE PARENT CLASS!!!"
        - To show cardinality/"has-a" relationships (e.g. if a "Car" has a "Student" property and the "Student" could own multiple "Car"s), then we'd draw a line w/o arrows with numbers on the sides showing the cardinality
            - e.g. "1 ... owns ... *" means "1 student owns 0...infinite cars, and each car has 1 student"
        - Our 3rd and final type of association between classes is AGGREGATION
            - This is when something "is made up of" an object that's important for it, e.g. a "Car" has-a "Engine"
                - Like the cardinality relationship, this usually translates to an Instance method in Java
            - To ACTUALLY draw this, we draw an arrow FROM the component (e.g. the engine) pointing TO the aggregate (the Car); BUT, the arrowhead is a "diamond" shape, instead of a triangle
                - This diamond could be either hollow or colored in solid; the hollow one means "Aggregation" ,the solid one means "Composition"
                    - "Aggregation" means that the components are separate from one another; if a board game piece disappers, then the board game as a whole will still exist
                    - "Composition" means that the object is actually PART OF the object; If the board is destroyed, then the "Squares" making up the board will ALSO be destroyed
                        - Coding-wise, this tells us how tightly to couple these objects, as well as how to handle memory in languages w/o garbage collection

- Later on in this class, we're going to talk about "Coupling", and how to decide how much objects should rely on each other. 
    - To show that a relationship only goes 1 way (e.g. students know what Car they own, but cars don't know about what Student owns them), we draw an unclosed arrow pointing FROM the object that knows the info

- For Interfaces, we show the class is an interface by writing "&lt;&lt;Interface&gt;&gt;" over the class name, just like our stereotypes in our domain model!
    - We then show a class IMPLEMENTS the interface by drawing an arrow w/ a dashed line FROM the class implementing the interface TO the interface

- There's just a few more things to go over for Class Diagrams...but we'll go over those on Wednesday. Enjoy the long weekend!</pre>
</article>
<a class="side-link is-note-link" href="18_classDiagrams_10_11_17.html"></a>
</main>
</body>
</html>