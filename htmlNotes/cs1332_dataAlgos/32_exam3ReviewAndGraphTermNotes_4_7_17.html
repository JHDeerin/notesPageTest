<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../../css/testStyle.css" rel="stylesheet"/>
<link href="../../css/notePageStyle.css" rel="stylesheet"/>
<link href="../../css/cs1332Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../../js/wrapText.js"></script>
<script defer="" src="../../js/pageTransitions.js"></script>
<script async="" defer="" src="../../js/loadMathJax.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Data Structures / Algorithms</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li class="active-note-page"><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="31_theLastStringSearchNotes_4_5_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre id="text-width-ruler"></pre>
<pre class="main-note-text">//**********************************************************************//
/***********Exam 3 Review / Graphs Vocab - April 7th, 2017*************//
//********************************************************************//

-REALITY CHECK!
    1) Given the following code which starts the Radix Sort algorithm, complete the code for Radix Sort (LSD):
        "public static int[] radixSort(int[] arr) {
            if (arr == null) {
                throw new IllegalArgumentException("Null args illegal");
            }
            LinkedList&lt;Integer&gt;[] counter;
            counter = (LinkedList&lt;Integer&gt;[]) new LinkedList[19];
            for (int i = 0; i &lt; 19; i++) {
                counter[i] = new LinkedList&lt;&gt;();
            }
            int mod = 10; //base of our sort
            int dev = 1; //divisor
            boolean cont = true;
            while (cont) {
                //(...your code below here...)

        }"

    //TA SOLUTION:
        (...)
        while (cont) {
            for (int i = 0; i &lt; arr.length; i++) {
                int digit = (arr[i] / dev) % mod + (mod - 1) //last part, "mod - 1", handles negatives (e.g. 1 goes in the 10th bucket)
                counter[digit].add(arr[i]);
            }
            int nextIndex = 0;
            for (LinkedList&lt;Integer&gt; bucket : counter) {
                while (!bucket.isEmpty) {
                    arr[nextIndex++] = bucket.remove();
                }
            }
            dev *= 10;
            if (Integer.MAX_VALUE / mod = dev) { //MISSED THIS PART, but says when to stop the sort
                cont = false;
            }
        }

    2) Write the code for the merge sort "Merge" method given the description below:
        "/**
        /* This is a private helper message that will merge the elements
        /* into a sorted list
        /*
        /* @param &lt;T&gt; data type to sort
        /* @param arr the original array
        /* @param a the left half of the array to be merged
        /* @param b the right half of the array to be merged
        /* @ param comparator the comparator that will compare the elements"

        private static &lt;T&gt; void merge(T[] arr, T[] a, T[] b, Comparator&lt;T&gt;
                comparator) {
            int i = 0;
            int j = 0;
            while (i &lt; a.length &amp;&amp; j &lt; b.length) {
                arr[i + j] = (comparator.Compare(a[i], b[j]) &lt;= 0)
                        ? a[i++] : b[j++];
            }
            while (i &lt; a.length) {
                arr[i + j] = a[i++];
            }
            while (j &lt; b.length) {
                arr[i + j] = b[j++];
            }
        }

        //TAs way (TAs EXPLICITLY said there were multiple ways)
        int i = 0;
        while (i &lt; arr.length) {
            if (i &gt;= arr.length) {
                //...basically, they did everything inside a single while loop; way that I did it (above) was perfectly fine as well
            }
        }

    3)  Write the following methods for an AVL tree in Java:
        private AVLNode&lt;T&gt; leftRotation(AVLNode&lt;T&gt; node) {

        }

        private AVLNode&lt;T&gt; rightRotation(AVLNode&lt;T&gt; node) {

        }

        MY ATTEMPT:
            private AVLNode&lt;T&gt; leftRotation(AVLNode&lt;T&gt; node) {
                AVLNode&lt;T&gt; newRoot = node.getRight();
                node.setRight(newRoot.getLeft());
                newRoot.setLeft(node);

                updateHeightBF(node);
                updateHeightBF(newRoot);

                return newRoot;
            }
                -Was mostly good, but I forgot to include the "updateHeight" portion until after the TA example; currently, this code matches the TAs example

            private AVLNode&lt;T&gt; rightRotation(AVLNode&lt;T&gt; node) {
                AVLNode&lt;T&gt; newRoot = node.getLeft();
                node.setLeft(newRoot.getRight());
                newRoot.setRight(node);

                updateHeightBF(node);
                updateHeightBF(newRoot);

                return newRoot;
            }

            -Here's the updateHeight method:
            "private void updateHeightBF(AVLNode&lt;T&gt; mode) {
                node.balanceFactor = getHeight(node.left) -
                        getHeight(node.right);
                node.height = Math.max(getHeight(node.left),
                        getHeight(node.right)) + 1;
            }

            private int getHeight(AVLNode&lt;T&gt; node) {
                if (node == null) {
                    return - 1;
                }
                return node.height;
            }"

-On Monday, we'll start talking about Graphs: some common terminology, graph modeling, searching algorithms for graphs,
-A few quick things for right now (NOT on the exam):
    -A GRAPH is a set of "nodes" (or VERTICES) and a collection of EDGES (or "arcs") that connect pairs of vertices
    -The ORDER of a graph is the # of vertices; the SIZE is the # of edges
    -The DEGREE of a vertex is the # of edges connected (or "incident") to that vertex
        -If all the vertices have the same degree, then we say that the whole graph has that degree
    -A PATH is a set of edges that can be followed to connect 2 nodes

    -Graphs CAN have vertices that aren't connected to any edges
    -Graphs can be DIRECTED, where their edges only go in one direction
        -One vertex is the origin, another is the destination; can ONLY go from the origin to the destination
        -Usually written as an ordered pair (u, v), where "u" is the origin and "v" is the other
    -Graphs can also be UNDIRECTED, where edges can go in both directions
    -Graphs can be WEIGHTED, where there are "weights" or "costs" associated with each edge

    -A SELF-LOOP is an edge connecting a vertex to itself
    -Two edges are "parallel" if they connect the same pair of vertices
        -i.e. you can have MULTIPLE edges between 2 vertices
    -We say vertices are ADJACENT if an edge connects two vertices to each other
    -As we said, a PATH is a sequence of vertices connected by edges to get from one vertex to another
        -A SIMPLE PATH is one with no repeated vertices (we only visit each vertex in the path once)

    -The 2 most common graph implementations:
        -ADJACENCY MATRIX
        -ADJACENCY LIST
    -We'll go over these on Monday
</pre>
</article>
<a class="side-link is-note-link" href="33_introGraphTheoryNotes_4_10_17.html"></a>
</main>
</body>
</html>