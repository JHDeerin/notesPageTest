<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0" name="viewport"/>
<title>Jake's CS Notes - Data Structures / Algorithms</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet"/>
<link href="../../css/testStyle.css" rel="stylesheet"/>
<link href="../../css/notePageStyle.css" rel="stylesheet"/>
<link href="../../css/cs1332Theme.css" id="class-theme-styles" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" rel="stylesheet"/>
</head>
<body>
<script defer="" src="../../js/wrapText.js"></script>
<script defer="" src="../../js/pageTransitions.js"></script>
<script async="" defer="" src="../../js/loadMathJax.js"></script>
<nav class="nav-top">
<ul>
<li class="link-with-slash"><a href="../../index.html"><i class="fas fa-home"></i></a></li>
<li><a href="#" id="class-title-link">Data Structures / Algorithms</a></li>
</ul>
<ul class="note-links-slider"><li><a class="is-note-link" href="0_firstDayNotes_1_9_17.html">0. First Day of Class!</a></li><li><a class="is-note-link" href="1_arrayListNotes_1_11_17.html">1. Arrays &amp; ArrayLists</a></li><li><a class="is-note-link" href="2_linkedListNotes_1_13_17.html">2. Linked Lists</a></li><li><a class="is-note-link" href="3_linkedListTypes_1_18_17.html">3. Linked List Types</a></li><li><a class="is-note-link" href="4_stackNotes_1_20_17.html">4. Stacks</a></li><li><a class="is-note-link" href="5_queueNotes_1_23_17.html">5. Queues</a></li><li><a class="is-note-link" href="6_recursionNotes_1_25_17.html">6. Recursion</a></li><li><a class="is-note-link" href="7_introTreeNotes_1_27_17.html">7. Intro. to Trees</a></li><li><a class="is-note-link" href="8_treeTraversalNotes_1_30_17.html">8. Tree Traversals</a></li><li><a class="is-note-link" href="9_binarySearchTreeNotes_2_1_17.html">9. Binary Search Trees</a></li><li><a class="is-note-link" href="10_iteratorNotes_2_3_17.html">10. Iterators</a></li><li><a class="is-note-link" href="11_heapNotes_2_6_17.html">11. Heaps</a></li><li><a class="is-note-link" href="12_moreHeapNotes_2_10_17.html">12. Heaps (cont.)</a></li><li><a class="is-note-link" href="13_hashMapNotes_2_13_17.html">13. Intro. to Hashmaps</a></li><li><a class="is-note-link" href="14_moreHashMapNotes_2_15_17.html">14. Hashmaps (cont.)</a></li><li><a class="is-note-link" href="15_skipListNotes_2_17_17.html">15. Skip Lists</a></li><li><a class="is-note-link" href="16_avlTreeNotes_2_20_17.html">16. AVL Trees</a></li><li><a class="is-note-link" href="17_randomRealityCheck_2_22_17.html">17. Random Reality Check</a></li><li><a class="is-note-link" href="18_moreAvlTreeNotes_2_24_17.html">18. AVL Trees (cont.)</a></li><li><a class="is-note-link" href="19_splayTreeNotes_2_27_17.html">19. Splay Trees</a></li><li><a class="is-note-link" href="20_bTreeNotes_3_1_17.html">20. B Trees</a></li><li><a class="is-note-link" href="21_moreBTreeNotes_3_3_17.html">21. B Trees (cont.)</a></li><li><a class="is-note-link" href="22_reviewAndSortIntro_3_6_17.html">22. Review / Intro. to Sorting</a></li><li><a class="is-note-link" href="23_basicSortingAlgoNotes_3_10_17.html">23. Basic Sorting Algorithms</a></li><li><a class="is-note-link" href="24_moreSortingAlgoNotes_3_13_17.html">24. Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="25_evenMoreSortingAlgoNotes_3_15_17.html">25. Advanced Sorting Algorithms (cont.)</a></li><li><a class="is-note-link" href="26_radixSortNotes_3_17_17.html">26. Radix Sort</a></li><li><a class="is-note-link" href="27_kthSelectionNotes_3_27_17.html">27. Kth Selection</a></li><li><a class="is-note-link" href="28_stringSearchNotes_3_29_17.html">28. String Searching</a></li><li><a class="is-note-link" href="29_moreStringSearchNotes_3_31_17.html">29. String Searching (cont.)</a></li><li><a class="is-note-link" href="30_evenMoreStringSearchNotes_4_3_17.html">30. KMP String Searching (cont.)</a></li><li><a class="is-note-link" href="31_theLastStringSearchNotes_4_5_17.html">31. Rabin Karp String Search</a></li><li><a class="is-note-link" href="32_exam3ReviewAndGraphTermNotes_4_7_17.html">32. Exam 3 Review / Graphs Vocab</a></li><li><a class="is-note-link" href="33_introGraphTheoryNotes_4_10_17.html">33. Intro to Graph Theory</a></li><li class="active-note-page"><a class="is-note-link" href="34_introGraphTheoryDijkstra_4_14_17.html">34. Dijkstra's Algorithm</a></li><li><a class="is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html">35. Minimum Spanning Trees</a></li><li><a class="is-note-link" href="36_introDynamicProgrammingNotes_4_19_17.html">36. Intro. to Dynamic Programming</a></li><li><a class="is-note-link" href="37_theLastLectureNotes_4_24_17.html">37. Last Lecture :(</a></li></ul>
</nav>
<main>
<a class="side-link is-note-link" href="33_introGraphTheoryNotes_4_10_17.html"></a>
<article>
<!-- Actual note text goes into 'pre' -->
<pre id="text-width-ruler"></pre>
<pre class="main-note-text">//********************************************************************//
//************Dijkstra's Algorithm - April 14th, 2017****************//
//******************************************************************//

-It's Good Friday already...wow. It completely snuck up on me; this year actually flew.
-Someone just asked if they could replace their lowest grade with the practice ArrayList homework...ah, GT. Never change.
    -UPDATE: And 2 days later, they get their wish. "We will now be replacing everyone's lowest homework grade with their practice homewo..."
        -...
-Also, HB isn't wearing glasses for the first time this semester! That's...all the exciting news I can think of
    -"I have really good news! The average on this test was an 83%, and we had multiple students who scored 100%!"
        -TA Scott whispering in the background: "...yeah, because we made the test easy as **** this semester..."
-String Search homework is due on MONDAY! So start that as soon as you can!
-The plan is to finish up graphs on Monday or Wednesday, then to spend the rest of the time teaching you dynamic programming
    -And after that...we're done! We only have 2 more weeks, and then the final!
-The final is cumulative, so be prepared for us to ask ANYTHING on it
-CIOS survey: if there is 70% participation, you'll all receive ONE WHOLE EXTRA POINT!
    -...yay?
--------------------------------------------------------

-So, we went over the two basic traversals: DFS and BFS. NOW, we're going to start going through some of the actual "algorithms" involving graphs

-The first one we'll go over is DIJKSTRA'S ALGORITHM!
    -DIJKSTRA'S algorithm is a graph algorithm for finding the shortest path on a graph (weighted or unweighted) from a specified start node to the next
        -Alternatively, it CAN be written to find the shortest path from a given node to ALL the other nodes
    -We do NOT revisit nodes in our path; for each path, we go through each node only once
    -To do this, we move forward using BFS, and then find the shortest path

    -Dijkstra's algorithm computes the distance of all vertices from a given start node

    -So, we START at the given start node; we then use BFS to find the nodes adjacent to START (using BFS) and consider their weights; we ignore all the other nodes adjacent to the current one (pretend they have infinite weight to travel to)
    -We then move forward to the node with the least weight (i.e., the "closest" node)
        -Store the distance of the path from START to each node in a table
    -Continue expanding outward; if we find a SHORTER path to that node as we expand our path and consider all edges, then we update the table and replace it with the shorter path
    -Continue until we've gone through all nodes, or have found the node we're looking for

    -PSEUDOCODE:
        //I THINK that right now, this just gets us the distance for the shortest path, rather than the path itself; not sure though
        Dijkstra(Vertex start, Graph g) {
            new int[] dist = new int[g.length];
            dist[start] = 0 //dist stores the distance from "start" to the given vertex
            for each Vertex v in g
                if (v != start)
                    dist[v] = infinity //set the rest of the distances as high as we can, so they'll be replaced as we find the shortest path
            visitedVertices =  new set //sometime called "S"
            unvisitedVertices = new Queue&lt;Vertex&gt;(g) //adds all vertices in "g;" using a priority Queue is the most efficient, since it can keep the shortest distance vertex "loaded" for us to grab right away
            while (!unvisitedVertices.isEmpty())
                Vertex u = closest vertex in unvisitedVertices (from START, I think?)
                visitedVertices.add(u)
                for each Vertex v adjacent to u
                    if (dist[v] &gt; dist[u] + w(u, v)) //if we've found a shorter path; w(u,v) is "distance from u to v"
                        dist[v] = dist[u] + w(u, v)

            return dist;
        }

    -So, that seems kind of complicated, doesn't it? Well, it is, but don't worry; Dijkstra's is the hardest graph topic that we teach in this course
</pre>
</article>
<a class="side-link is-note-link" href="35_introGraphTheoryMSTs_4_17_17.html"></a>
</main>
</body>
</html>